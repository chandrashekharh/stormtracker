// Generated by CoffeeScript 1.6.1
(function() {
  var AsyncTestCase, SafeAssert, TestCase, TestSuite, ThreadBarrier, assert, fs, inspect, print, puts,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  assert = require("assert");

  puts = require("util").debug;

  print = require("util").debug;

  fs = require("fs");

  inspect = require("util").inspect;

  ThreadBarrier = require("util/concurrent").ThreadBarrier;

  TestCase = (function() {

    function TestCase(name, block) {
      this.name = name;
      this.block = block;
      this.assert = new SafeAssert;
      this.hasBeenRun = false;
    }

    TestCase.prototype.run = function(suite) {
      this.block(this.assert);
      if (this.hasBeenRun) {
        return puts("WARNING!!!! Test cases should not be run more than once! Skipping the next test case in our suite... (Offending test case: " + this.name + ")");
      }
      this.hasBeenRun = true;
      return suite.done(this);
    };

    return TestCase;

  })();

  AsyncTestCase = (function(_super) {

    __extends(AsyncTestCase, _super);

    function AsyncTestCase() {
      return AsyncTestCase.__super__.constructor.apply(this, arguments);
    }

    AsyncTestCase.prototype.run = function(suite) {
      this.suite = suite;
      return this.block(this.assert, this);
    };

    AsyncTestCase.prototype.done = function() {
      if (this.hasBeenRun) {
        return puts("WARNING!!!! Test cases should not be run more than once! Skipping the next test case in our suite... (Offending test case: " + this.name + ")");
      }
      this.hasBeenRun = true;
      return this.suite.done(this);
    };

    return AsyncTestCase;

  })(TestCase);

  global.badExitHandler = function() {
    return puts(inspect(global.badExit));
  };

  TestSuite = (function() {

    function TestSuite() {
      var test, _i, _len;
      this.tests = [];
      this.testCounter = 0;
      for (_i = 0, _len = arguments.length; _i < _len; _i++) {
        test = arguments[_i];
        this.tests.push(test);
      }
      this.barrier = null;
      global.badExit = {};
    }

    TestSuite.prototype.addTest = function(test) {
      this.tests.push(test);
      return this;
    };

    TestSuite.prototype.newTest = function(name, block) {
      this.addTest(new TestCase(name, block));
      return this;
    };

    TestSuite.prototype.newAsyncTest = function(name, block) {
      this.addTest(new AsyncTestCase(name, block));
      return this;
    };

    TestSuite.prototype.run = function() {
      var self, test, _i, _len, _ref, _results;
      process.on('exit', global.badExitHandler);
      process.on('unhandledException', global.badExitHandler);
      self = this;
      this.barrier = new ThreadBarrier(this.tests.length, function() {
        return self.finish();
      });
      if (this.before) {
        this.before();
      }
      _ref = this.tests;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        test = _ref[_i];
        _results.push((function(test) {
          return setTimeout(function() {
            return test.run(self);
          }, 0);
        })(test));
      }
      return _results;
    };

    TestSuite.prototype.done = function(test) {
      delete global.badExit[test.name];
      return this.barrier.join();
    };

    TestSuite.prototype.finish = function() {
      this.report();
      process.removeListener("exit", global.badExitHandler);
      process.removeListener("unhandledException", global.badExitHandler);
      if (this.after) {
        return this.after();
      }
    };

    TestSuite.prototype.report = function() {
      var failed, failure, passed, result, test, _i, _j, _len, _len1, _ref, _ref1;
      passed = 0;
      failed = 0;
      _ref = this.tests;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        test = _ref[_i];
        if (test.assert.failures.length === 0) {
          result = "PASSED";
          ++passed;
        } else {
          result = "FAILED";
          ++failed;
        }
        puts("" + test.name + " " + result + " [" + test.assert.succeeded + " / " + (test.assert.failures.length + test.assert.succeeded) + "]");
        _ref1 = test.assert.failures;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          failure = _ref1[_j];
          puts("  Error: " + failure);
        }
      }
      result = "FAILED";
      if (failed === 0) {
        result = "PASSED";
      }
      return puts("Suite Results: " + result + " Tests Run: " + (passed + failed) + " Passed: " + passed + " Failed: " + failed);
    };

    return TestSuite;

  })();

  SafeAssert = (function() {

    function SafeAssert() {
      this.failures = [];
      this.succeeded = 0;
      this.name = "SafeAssert";
    }

    SafeAssert.prototype.fail = function(actual, expected, message, operator, stackStartFunction) {
      return this.failures.push(new assert.AssertionError({
        actual: actual,
        expected: expected,
        message: message,
        operator: operator,
        stackStartFunction: stackStartFunction
      }));
    };

    SafeAssert.prototype.ok = function(value, message) {
      try {
        assert.ok(value, message);
        return ++this.succeeded;
      } catch (e) {
        return this.failures.push(e);
      }
    };

    SafeAssert.prototype.isTrue = function(value, message) {
      return this.ok(value, message);
    };

    SafeAssert.prototype.equal = function(actual, expected, message) {
      try {
        assert.equal(actual, expected, message);
        return ++this.succeeded;
      } catch (e) {
        return this.failures.push(e);
      }
    };

    SafeAssert.prototype.notEqual = function(actual, expected, message) {
      try {
        assert.notEqual(actual, expected, message);
        return ++this.succeeded;
      } catch (e) {
        return this.failures.push(e);
      }
    };

    SafeAssert.prototype.deepEqual = function(actual, expected, message) {
      try {
        assert.deepEqual(actual, expected, message);
        return ++this.succeeded;
      } catch (e) {
        return this.failures.push(e);
      }
    };

    SafeAssert.prototype.notDeepEqual = function(actual, expected, message) {
      try {
        assert.notDeepEqual(actual, expected, message);
        return ++this.succeeded;
      } catch (e) {
        return this.failures.push(e);
      }
    };

    SafeAssert.prototype.isNull = function(actual, message) {
      try {
        assert.equal(actual, null, message);
        return ++this.succeeded;
      } catch (e) {
        return this.failures.push(e);
      }
    };

    SafeAssert.prototype.isNotNull = function(actual, message) {
      try {
        assert.notEqual(actual, null, message);
        return ++this.succeeded;
      } catch (e) {
        return this.failures.push(e);
      }
    };

    SafeAssert.prototype.strictEqual = function(actual, expected, message) {
      try {
        assert.strictEqual(actual, expected, message);
        return ++this.succeeded;
      } catch (e) {
        return this.failures.push(e);
      }
    };

    SafeAssert.prototype.notStrictEqual = function(actual, expected, message) {
      try {
        assert.notStrictEqual(actual, expected, message);
        return ++this.succeeded;
      } catch (e) {
        return this.failures.push(e);
      }
    };

    SafeAssert.prototype.throws = function(block, error, message) {
      try {
        assert.throws(block, error, message);
        return ++this.succeeded;
      } catch (e) {
        return this.failures.push(e);
      }
    };

    SafeAssert.prototype.doesNotThrow = function(block, error, message) {
      try {
        assert.doesNotThrow(block, error, message);
        return ++this.succeeded;
      } catch (e) {
        return this.failures.push(e);
      }
    };

    SafeAssert.prototype.fileExists = function(file) {
      var me, stat;
      me = this;
      stat = fs.statSync(file);
      try {
        if (stat.size === 0) {
          me.fail("We were expecting the file '" + file + "' to be of non-zero length but it wasn't.");
        }
        return ++me.succeeded;
      } catch (e) {
        return me.failures.push(e);
      }
    };

    SafeAssert.prototype.fileAbsent = function(file) {
      var me, stat;
      me = this;
      try {
        stat = fs.statSync(file);
        me.fail("File " + file + " exists but it shouldn't.");
      } catch (e) {
        return ++me.succeeded;
      }
    };

    SafeAssert.prototype.isError = function(value, message) {
      if (assert.ifError(value)) {
        return this.fail(message);
      } else {
        return ++this.succeeded;
      }
    };

    SafeAssert.prototype.isNotError = function(value, message) {
      if (value) {
        return this.fail(message);
      } else {
        return ++this.succeeded;
      }
    };

    return SafeAssert;

  })();

  exports.SafeAssert = SafeAssert;

  exports.TestCase = TestCase;

  exports.AsyncTestCase = AsyncTestCase;

  exports.TestSuite = TestSuite;

}).call(this);
