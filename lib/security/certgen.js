// Generated by CoffeeScript 1.7.1
(function() {
  var CONFIG_DIR, CSR, Semaphore, TEMP_DIR, ThreadBarrier, buildSubj, bundle, exclusive, exec, findExtensions, fs, genCSR, genConfig, genExtensions, genKey, genSelfSigned, getCertFingerprint, initSerialFile, inspect, pcs12, pkcs12, puts, randFile, randomString, selfSign, sign, signCSR, spawn, srlFile, verify, verifyCSR;

  exec = require("child_process").exec;

  spawn = require("child_process").spawn;

  fs = require("fs");

  puts = require("util").debug;

  inspect = require("util").inspect;

  Semaphore = require("util/concurrent").Semaphore;

  ThreadBarrier = require("util/concurrent").ThreadBarrier;

  exclusive = new Semaphore;

  srlFile = "serial.srl";

  TEMP_DIR = "/tmp";

  CONFIG_DIR = "config";

  randomString = function(bits) {
    var chars, i, rand, ret;
    chars = void 0;
    rand = void 0;
    i = void 0;
    ret = void 0;
    chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz012345678901";
    ret = "";
    while (bits > 0) {
      rand = Math.floor(Math.random() * 0x100000000);
      i = 26;
      while (i > 0 && bits > 0) {
        ret += chars[0x3F & rand >>> i];
        i -= 6;
        bits -= 6;
      }
    }
    return ret;
  };

  randFile = function() {
    return randomString(512);
  };


  /**
   * Construct an x509 -subj argument from an options object.
   * @param {Object} options An options object with optional email and hostname.
   * @return {String} A string suitable for use with x509 as a -subj argument.
   */

  buildSubj = function(options) {
    var key, subject, value;
    subject = "";
    for (key in options) {
      value = options[key];
      if (key.length < 3) {
        key = key.toUpperCase();
      }
      if (key === "O" || key === "OU" || key === "L" || key === "C" || key === "ST" || key === "CN" || key === "emailAddress" || key === "commonName" || key === "state" || key === "organization" || key === "organizationalUnit" || key === "country" || key === "locality") {
        subject = "" + subject + "/" + key + "=" + value;
      }
    }
    return subject;
  };

  genConfig = function(options, callback) {
    return fs.readFile(CONFIG_DIR + "/openssl.cnf.template", function(err, confTemplate) {
      var confFile;
      if (err != null) {
        return callback(err);
      }
      confTemplate = confTemplate.toString().replace(/%%SUBJECT_ALT_NAME%%/g, (options.subjectAltName != null ? options.subjectAltName : ""));
      confTemplate = confTemplate.toString().replace(/%%NSCOMMENT%%/g, (options.nsComment != null ? options.nsComment : ""));
      confTemplate = confTemplate.toString().replace(/%%BASIC_CONSTRAINTS%%/g, ((options.CA != null) && options.CA ? "CA:TRUE" : "CA:FALSE"));
      confTemplate = confTemplate.toString().replace(/CA:TRUE/g, ((options.pathlen != null) && options.pathlen > -1 ? "CA:TRUE,pathlen:" + options.pathlen : "CA:TRUE"));
      confFile = TEMP_DIR + ("/" + (randFile()));
      return fs.writeFile(confFile, confTemplate, function(err) {
        if (err != null) {
          return callback(err);
        }
        return callback(null, confFile);
      });
    });
  };

  genExtensions = function(options, callback) {
    var CA, confFile, confTemplate, k, v;
    puts(inspect(options));
    CA = "FALSE";
    if (options.CA) {
      CA = "TRUE";
    }
    confTemplate = "basicConstraints=critical,CA:" + CA;
    if (options.CA && (options.pathlen != null) && options.pathlen > -1) {
      confTemplate += ",pathlen:" + options.pathlen;
    }
    confTemplate += "\n";
    confTemplate += "subjectKeyIdentifier=hash\nauthorityKeyIdentifier=keyid,issuer\nkeyUsage = nonRepudiation, digitalSignature, keyEncipherment, dataEncipherment, keyAgreement, keyCertSign, cRLSign";
    confTemplate += "\n";
    confTemplate += "extendedKeyUsage=critical,serverAuth,clientAuth,codeSigning,emailProtection,timeStamping\n";
    for (k in options) {
      v = options[k];
      if ((k === "subjectAltName" || k === "nsComment")) {
        confTemplate += "" + k + "=" + v + "\n";
      }
    }
    confFile = TEMP_DIR + ("/" + (randFile()));
    return fs.writeFile(confFile, confTemplate, function(err) {
      if (err != null) {
        return callback(err);
      }
      return callback(null, confFile);
    });
  };

  findExtensions = function(csr, callback) {
    return verifyCSR(csr, function(err, text) {
      var i, item, match, result, _i, _len;
      if (err != null) {
        return callback(err);
      }
      text = text.toString();
      text = text.split("\n");
      result = {};
      for (i = _i = 0, _len = text.length; _i < _len; i = ++_i) {
        item = text[i];
        if (text[i].indexOf("X509v3 Subject Alternative Name:") > -1) {
          result.subjectAltName = text[i + 1].trim();
        }
        if (text[i].indexOf("Netscape Comment:") > -1) {
          result.nsComment = text[i + 1].trim();
        }
        if (text[i].indexOf("X509v3 Basic Constraints:") > -1) {
          puts(text[i + 1]);
          result.CA = text[i + 1].trim().toUpperCase().indexOf("CA:TRUE") > -1;
          match = text[i + 1].trim().match(/.*pathlen:(\d+)/);
          if ((match != null) && match.length > 1) {
            result.pathlen = match[1];
          }
        }
      }
      return callback(null, result);
    });
  };


  /**
   * Generates a Self signed X509 Certificate.
   *
   * @param {String} outputKey Path to write the private key to.
   * @param {String} outputCert Path to write the certificate to.
   * @param {Object} options An options object with optional email and hostname.
   * @param {Function} callback fired with (err).
   */

  genSelfSigned = function(options, daysValidFor, callback) {
    var certFile, keyFile, optionString, reqArgs, subjectAltName;
    keyFile = TEMP_DIR + ("/" + (randFile()));
    certFile = TEMP_DIR + ("/" + (randFile()));
    subjectAltName = null;
    optionString = options;
    if (typeof options === "object") {
      optionString = buildSubj(options);
    }
    reqArgs = ["-batch", "-x509", "-nodes", "-days " + daysValidFor, "-subj \"" + optionString + "\"", "-sha1", "-newkey rsa:2048", "-keyout " + keyFile, "-out " + certFile];
    return genConfig(options, function(err, confFile) {
      if (err != null) {
        return callback(err);
      }
      reqArgs.push("-config " + confFile);
      return selfSign(reqArgs, certFile, keyFile, confFile, callback);
    });
  };

  selfSign = function(reqArgs, certFile, keyFile, confFile, callback) {
    var cmd;
    cmd = "openssl req " + reqArgs.join(" ");
    return exec(cmd, function(err, stdout, stderr) {
      var b, cert, key;
      fs.unlink(confFile);
      if (err != null) {
        fs.unlink(certFile);
        fs.unlink(keyFile);
        return callback(err);
      }
      key = cert = "";
      ThreadBarrier(b = new ThreadBarrier(2, function() {
        return callback(null, key, cert);
      }));
      fs.readFile(certFile, function(certErr, myCert) {
        fs.unlink(certFile);
        cert = myCert;
        return b.join();
      });
      return fs.readFile(keyFile, function(keyErr, myKey) {
        fs.unlink(keyFile);
        key = myKey;
        return b.join();
      });
    });
  };


  /**
   * Generate an RSA key.
   *
   * @param {String} outputKey Location to output the key to.
   * @param {Function} callback Callback fired with (err).
   */

  genKey = function(callback) {
    var args, cmd, keyFile;
    keyFile = TEMP_DIR + ("/" + (randFile()));
    args = ["-out " + keyFile, 2048];
    cmd = "openssl genrsa " + args.join(" ");
    return exec(cmd, function(err, stdout, stderr) {
      if (err != null) {
        fs.unlink(keyFile);
        return callback(err);
      }
      return fs.readFile(keyFile, function(err, key) {
        fs.unlink(keyFile);
        if (err != null) {
          return callback(err);
        }
        return callback(null, key);
      });
    });
  };


  /**
   * Generate a CSR for the specified key, and pass it back as a string through
   * a callback.
   * @param {String} inputKey File to read the key from.
   * @param {String} outputCSR File to store the CSR to.
   * @param {Object} options An options object with optional email and hostname.
   * @param {Function} callback Callback fired with (err, csrText).
   */

  genCSR = function(key, options, callback) {
    var CSRFile, args, keyFile, subject, subjectAltName;
    keyFile = TEMP_DIR + ("/" + (randFile()));
    CSRFile = TEMP_DIR + ("/" + (randFile()));
    subjectAltName = null;
    subject = options;
    if (typeof options === "object") {
      subject = buildSubj(options);
    }
    args = ["-batch", "-new", "-nodes", "-subj \"" + subject + "\"", "-key " + keyFile, "-out " + CSRFile];
    return fs.writeFile(keyFile, key, function(err) {
      if (err != null) {
        return callback(err);
      }
      return genConfig(options, function(err, confFile) {
        if (err != null) {
          return callback(err);
        }
        args.push("-config " + confFile);
        return CSR(args, keyFile, CSRFile, confFile, callback);
      });
    });
  };

  CSR = function(args, keyFile, CSRFile, confFile, callback) {
    var cmd;
    cmd = "openssl req " + args.join(" ");
    return exec(cmd, function(err, stdout, stderr) {

      /*fs.unlink confFile if confFile? */
      if (err != null) {
        return callback("Error while executing: " + cmd + "\n" + err);
      }
      fs.unlink(keyFile);
      fs.unlink(confFile);
      return fs.readFile(CSRFile, function(err, csr) {
        if (err != null) {
          return callback(err);
        }
        fs.unlink(CSRFile);
        return callback(null, csr);
      });
    });
  };


  /**
   * Initialize an openssl '.srl' file for serial number tracking.
   * @param {String} srlPath Path to use for the srl file.
   * @param {Function} callback Callback fired with (err).
   */

  initSerialFile = function(callback) {
    return fs.writeFile(srlFile, "00", callback);
  };


  /**
   * Verify a CSR.
   * @param {String} csrPath Path to the CSR file.
   * @param {Function} callback Callback fired with (err).
   */

  verifyCSR = function(csr, callback) {
    var CSRFile, args, cmd;
    CSRFile = TEMP_DIR + ("/" + (randFile()));
    args = ["-verify", "-noout", "-in " + CSRFile + " -text"];
    cmd = "openssl req " + (args.join(" "));
    return fs.writeFile(CSRFile, csr, function(err) {
      if (err != null) {
        return callback(err);
      }
      return exec(cmd, function(err, stdout, stderr) {
        fs.unlink(CSRFile);
        return callback(err, stdout, stderr);
      });
    });
  };


  /**
   * Sign a CSR and store the resulting certificate to the specified location
   * @param {String} csrPath Path to the CSR file.
   * @param {String} caCertPath Path to the CA certificate.
   * @param {String} caKeyPath Path to the CA key.
   * @param {String} caSerialPath Path to the CA serial number file.
   * @param {String} outputCert Path at which to store the certificate.
   * @param {Function} callback Callback fired with (err).
   */

  signCSR = function(csr, caCert, caKey, daysValidFor, callback) {
    var barrier, certPath, csrPath, keyPath, outputPath;
    csrPath = TEMP_DIR + ("/" + (randFile()));
    certPath = TEMP_DIR + ("/" + (randFile()));
    keyPath = TEMP_DIR + ("/" + (randFile()));
    outputPath = TEMP_DIR + ("/" + (randFile()));
    barrier = new ThreadBarrier(3, function() {
      return findExtensions(csr, function(err, extensions) {
        puts(inspect(extensions));
        return genExtensions(extensions, function(err, extensionFile) {
          var args, cmd;
          if (err != null) {
            return callback(err);
          }
          args = ["-req", "-days " + daysValidFor, "-CA \"" + certPath + "\"", "-CAkey \"" + keyPath + "\"", "-CAserial \"" + srlFile + "\"", "-in " + csrPath, "-out " + outputPath, "-extfile " + extensionFile];
          cmd = "openssl x509 " + (args.join(" "));
          return exec(cmd, function(err, stdout, stderr) {
            fs.unlink(keyPath);
            fs.unlink(csrPath);
            fs.unlink(certPath);
            fs.unlink(extensionFile);
            if (err != null) {
              return callback("Error while executing: " + cmd + "\n" + err);
            }
            return fs.readFile(outputPath, function(err, output) {
              fs.unlink(outputPath);
              if (err != null) {
                return callback(err);
              }
              return callback(null, output);
            });
          });
        });
      });
    });
    fs.writeFile(csrPath, csr, function(err) {
      return barrier.join();
    });
    fs.writeFile(certPath, caCert, function(err) {
      return barrier.join();
    });
    return fs.writeFile(keyPath, caKey, function(err) {
      return barrier.join();
    });
  };


  /**
   * Retrieve a SHA1 fingerprint of a certificate.
   * @param {String} certPath Path to the certificate.
   * @param {Function} callback Callback fired with (err, fingerprint).
   */

  getCertFingerprint = function(cert, callback) {
    var certPath;
    certPath = TEMP_DIR + ("/" + (randFile()));
    return fs.writeFile(certPath, cert, function(err) {
      var args, cmd, segments;
      if (err) {
        return callback(err);
      }
      args = ["-noout", "-in \"" + certPath + "\"", "-fingerprint", "-sha1"];
      cmd = "openssl x509 " + (args.join(" "));
      exec(cmd, function(err, stdout, stderr) {
        return fs.unlink(certPath);
      });
      if (err) {
        if (callback != null) {
          callback(err, stdout, stderr);
        }
        return;
      }
      segments = stdout.split("=");
      if (segments.length !== 2 || segments[0] !== "SHA1 Fingerprint") {
        callback(new Error("Unexpected output from openssl"), stdout, stderr);
        return;
      }
      if (callback != null) {
        return callback(null, (segments[1] || '').replace(/^\s+|\s+$/g, ''));
      }
    });
  };

  sign = function(cert, key, ca, message, callback) {
    var args, barrier, caPath, certPath, cmd, keyPath, messagePath, sigPath;
    keyPath = TEMP_DIR + ("/" + (randFile()));
    messagePath = TEMP_DIR + ("/" + (randFile()));
    caPath = TEMP_DIR + ("/" + (randFile()));
    certPath = TEMP_DIR + ("/" + (randFile()));
    sigPath = TEMP_DIR + ("/" + (randFile()));
    barrier = new ThreadBarrier(4, function() {});
    args = ["-sign", "-inkey " + keyPath, "-out " + sigPath, "-signer " + certPath, "-certfile " + caPath, "-nodetach", "-outform der", "-in " + messagePath];
    cmd = "openssl smime " + (args.join(" "));
    exec(cmd, function(err, stdout, stderr) {
      fs.unlink(keyPath);
      fs.unlink(messagePath);
      fs.unlink(caPath);
      fs.unlink(certPath);
      if (err) {
        return callback(err, stdout, stderr);
      }
      return fs.readFile(sigPath, function(err, sig) {
        fs.unlink(sigPath);
        return callback(err, sig);
      });
    });
    fs.writeFile(keyPath, key, function(err) {
      return barrier.join();
    });
    fs.writeFile(messagePath, message, function(err) {
      return barrier.join();
    });
    fs.writeFile(caPath, ca, function(err) {
      return barrier.join();
    });
    return fs.writeFile(certPath, cert, function(err) {
      return barrier.join();
    });
  };

  verify = function(cert, sig, message, callback) {
    var barrier, certPath, messagePath, sigPath;
    certPath = TEMP_DIR + ("/" + (randFile()));
    messagePath = TEMP_DIR + ("/" + (randFile()));
    sigPath = TEMP_DIR + ("/" + (randFile()));
    barrier = new ThreadBarrier(3, function() {
      var args, cmd;
      args = ["-prverify " + certPath, "-signature " + sigPath];
      cmd = "openssl dgst -sha1 " + (args.join(" ")) + " " + messagePath;
      return exec(cmd, function(err, stdout, stderr) {
        fs.unlink(certPath);
        fs.unlink(messagePath);
        fs.unlink(sigPath);
        return callback(err, stdout, stderr);
      });
    });
    fs.writeFile(certPath, cert, function(err) {
      return barrier.join();
    });
    fs.writeFile(messagePath, message, function(err) {
      return barrier.join();
    });
    return fs.writeFile(sigPath, sig, function(err) {
      return barrier.join();
    });
  };

  bundle = function(certNames, callback) {
    var barrier, cert, certs, error, _i, _ref, _results;
    certs = new Array();
    barrier = new ThreadBarrier(certNames.length, function() {
      var x, _i, _len;
      bundle = "";
      for (_i = 0, _len = certs.length; _i < _len; _i++) {
        x = certs[_i];
        bundle += x;
      }
      return callback(null, bundle);
    });
    error = false;
    _results = [];
    for (cert = _i = 0, _ref = certNames.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; cert = 0 <= _ref ? ++_i : --_i) {
      _results.push((function(cert) {
        return fs.readFile("certs/" + certNames[cert] + ".cert", function(err, data) {
          if (err != null) {
            if (error) {
              return;
            }
            error = true;
            return callback(err);
          }
          certs[cert] = data.toString();
          return barrier.join();
        });
      })(cert));
    }
    return _results;
  };

  pcs12 = function(inCert, ca, name, callback) {
    var args, barrier, caFile, certFile, cmd, pkcsFile;
    certFile = TEMP_DIR + ("/" + (randFile()));
    pkcsFile = TEMP_DIR + ("/" + (randFile()));
    caFile = TEMP_DIR + ("/" + (randFile()));
    args = ["-export", "-nokeys", "-in \"" + certFile + "\"", "-passout pass:", "-out \"" + pkcsFile + "\"", "-CAfile \"" + caFile + "\"", "-certfile \"" + caFile + "\"", "-nodes", "-name \"" + name + "\""];
    cmd = "openssl pkcs12 " + (args.join(" "));
    barrier = new ThreadBarrier(2, function() {
      return exec(cmd, function(err, stdout, stderr) {
        fs.unlink(certFile);
        fs.unlink(caFile);
        if (err != null) {
          return callback(err);
        }
        return fs.readFile(pkcsFile, function(err, pkcs) {
          if (err != null) {
            return callback(err);
          }
          fs.unlink(pkcsFile);
          return callback(null, pkcs);
        });
      });
    });
    fs.writeFile(certFile, inCert, function(err) {
      if (err != null) {
        return callback(err);
      }
      return barrier.join();
    });
    return fs.writeFile(caFile, ca, function(err) {
      if (err != null) {
        return callback(err);
      }
      return barrier.join();
    });
  };

  pkcs12 = function(inKey, inCert, ca, name, callback) {
    var args, barrier, caFile, certFile, cmd, keyFile, pkcsFile;
    keyFile = TEMP_DIR + ("/" + (randFile()));
    certFile = TEMP_DIR + ("/" + (randFile()));
    pkcsFile = TEMP_DIR + ("/" + (randFile()));
    caFile = TEMP_DIR + ("/" + (randFile()));
    args = ["-export", "-inkey \"" + keyFile + "\"", "-in \"" + certFile + "\"", "-passout pass:password", "-out \"" + pkcsFile + "\"", "-CAfile \"" + caFile + "\"", "-certfile \"" + caFile + "\"", "-chain", "-nodes", "-name \"" + name + "\""];
    cmd = "openssl pkcs12 " + (args.join(" "));
    barrier = new ThreadBarrier(3, function() {
      return exec(cmd, function(err, stdout, stderr) {
        fs.unlink(keyFile);
        fs.unlink(certFile);
        fs.unlink(caFile);
        if (err != null) {
          return callback(err);
        }
        return fs.readFile(pkcsFile, function(err, pkcs) {
          if (err != null) {
            return callback(err);
          }
          fs.unlink(pkcsFile);
          return callback(null, pkcs);
        });
      });
    });
    fs.writeFile(keyFile, inKey, function(err) {
      if (err != null) {
        return callback(err);
      }
      return barrier.join();
    });
    fs.writeFile(certFile, inCert, function(err) {
      if (err != null) {
        return callback(err);
      }
      return barrier.join();
    });
    return fs.writeFile(caFile, ca, function(err) {
      if (err != null) {
        return callback(err);
      }
      return barrier.join();
    });
  };

  exports.genSelfSigned = genSelfSigned;

  exports.genKey = genKey;

  exports.genCSR = genCSR;

  exports.initSerialFile = initSerialFile;

  exports.verifyCSR = verifyCSR;

  exports.signCSR = signCSR;

  exports.getCertFingerprint = getCertFingerprint;

  exports.sign = sign;

  exports.verify = verify;

  exports.bundle = bundle;

  exports.pkcs12 = pkcs12;

  exports.pcs12 = pcs12;

  exports.TEMP_DIR = TEMP_DIR;

  exports.CONFIG_DIR = CONFIG_DIR;

}).call(this);
